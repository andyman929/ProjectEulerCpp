/*
The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let us list the factors of the first seven triangle numbers:

 1: 1
 3: 1,3
 6: 1,2,3,6
10: 1,2,5,10
15: 1,3,5,15
21: 1,3,7,21
28: 1,2,4,7,14,28
We can see that 28 is the first triangle number to have over five divisors.

What is the value of the first triangle number to have over five hundred divisors?
*/

#include "pch.h"

#define Round2Int(x) (int)(x > 0 ? (x + 0.5) : (x - 0.5))


// Try using a better method. Could find prime factor count using work from an earlier project
// and then find how many factors there are by counting subsets
void ProjectsObjDLL1::Project12CalcOld(int divs)
{
    __int64 triangle = 0;
    __int64 natural = 0;
    int divisors;
    
    while (true)
    {
        natural++;
        triangle += natural;
        divisors = 0;
        for (int i = 1; i <= triangle; i++)
        {
            if (triangle % i == 0)
                divisors++;
        }
        if (divisors > divs)
            break;
    }
    std::cout << "First triangle number with more than " << divs << " divisors is: " << triangle << " with " << divisors << " factors" << "\n";
}


// Better method
// Triangle numbers can be calculated as nth number is n(n+1)/2
// n and n+1 are coprime, so the number of common factors of the product is the product of their respective number of factors
// This should be easy to find, as I then just have to remove 1 to account for the 2, so if factors(n)*factors(n+1) > 501 we have a solution as the nth triangle number

// Got more complicated than I thought as you'd have to track the number of non-2 factors to find the remaining factors after division


// I think it works though, did some timing comparisons and we're talking milliseconds to minutes
void ProjectsObjDLL1::Project12Calc(int divs)
{
    int lastFactors = 1;
    int lastFactors2 = 0;
    int factors = 0;
    int factors2 = 0;
    int n = 1;

    int finalFactors = 0;
    int finalFactors2 = 0;

    int reduced;

    while (true)
    {
        n++;
        factors = 0;
        factors2 = 0;
        reduced = n;
        // I think the below falls apart if n is square, should maybe fix that
        for (int i = 1; i <= sqrt(n); i++)
        {
            if (n % i == 0)
            {
                factors += 2;
            }
        }
        while (reduced % 2 == 0)
        {
            factors2++;
            reduced /= 2;
        }
        finalFactors2 = factors2 + lastFactors2;
        finalFactors = Round2Int(factors * lastFactors * ((double)finalFactors2 / ((double)finalFactors2 + 1)));
        if (finalFactors > divs)
            break;

        lastFactors = factors;
        lastFactors2 = factors2;
    }

    int triangle;
    triangle = n * (n - 1) / 2;

    std::cout << "First triangle number with more than " << divs << " divisors is: " << triangle << " with " << finalFactors << " factors" << "\n";
}




